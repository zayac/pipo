PIPO testing utility
====================
PIPO is a primitive programming language aiming to simplify verification of
applications written on C language.

C language is used where efficiency and portability are important
characteristics. However, one of main C disadvantages are complicated debugging
and verification processes. Python is one of languages that doesn't show high
performance, however is helpful for prototyping, allowing programmers to
develop applications for a short period of time. Prototypes written on Python
can be used for testing automation. Given a scenario, PIPO generates a unittest
file, where expected function return values are generated by a prototype.

Inspired by [PLT Games contest](http://www.pltgames.com/competition/2013/1)

How PIPO works
--------------
A programmer compiles C code as a dynamic(.so) library and describes functions
and desirable input values for each function to test. PIPO generates a python
script which these functions with given inputs will be run and compared with
expected value taken from provided prototype. Currently only primitive input
variable types are supported.

To build compiler
-----------------
cd to the 'build' directory inside project folder, and compile binary there:
<pre>
$ cd build
$ cmake ..
$ make
</pre>
Syntax
------
The following language is used to describe testing scenario (language grammar
in EBNF):
<pre>
  PRG	      := MODULE_LIST
  MODULE_LIST := [ MODULE ]+
  MODULE      := validate 'id' { CASES }
  CASES	      := function <id> { ARG_LIST }
  ARG_LIST    := [ ARGS, ]* ARGS
  ARGS	      := ( [ ARG, ]* ARG )
  ARG	      := 'int' | 'hex_num' | 'oct_num' | 'real num' | 'string'
</pre>

Example
-------
Assume we want to implement a module with Fibonacci and factorial functions
implementations. First, we can implement a prototype on Python to understand
how functions should work. The major advantage here is that we can use high
level entities and libraries available in Python (but not in C).
<pre>
def factorial (n):
  if n <= 1:
    return 1
  return factorial (n - 1) * n

def fibonacci(n):
  if n == 0 or n == 1:
    return n
  else:
    return fibonacci (n - 1) + fibonacci (n - 2)
</pre>

Once done, we can implemented a module with Fibonacci and factorial sequences
computation in C.
<pre>
unsigned long long
factorial (unsigned long long n)
{
  if (n == 0)
    return 1;
  else
    return n * factorial (n - 1);
}

unsigned long long
fibonacci (unsigned long long n)
{
  if (n == 0 || n == 1)
    return n;
  else
    return fibonacci (n - 1) + fibonacci (n - 2);
}
</pre>

Both prototype and implementation must have the same file name without an
extension. In our case we will call them `totest.py` and `totest.c`.

Then let's compile C code as the library:
<pre>
  $ gcc -c -fpic totest.c -o totest.o
  $ gcc -shared totest.o -o libtotest.so
</pre>

The compiled library must have `lib` prefix in the filename.

Finally, the corectness of the implementation can be checked using PIPO. We write
a testing scenario for given module:
<pre>
validate totest
{
  function factorial {
    (0),
    (1),
    (5),
    (10)
  }

  function fibonacci {
    (1),
    (2),
    (5),
    (10),
    (20)
  }
}
</pre>

Assume it is called `test.pp`. Let's run PIPO translator to produce a unittest
python file:
<pre>
  $ ./pipo test.pp
</pre>

It produces `test.py` file which can run and check calculations result 
correspondance between C code and Python prototype:
<pre>
$ python test.py
test_factorial (__main__.Test_totest) ... ok
test_fibonacci (__main__.Test_totest) ... ok

----------------------------------------------------------------------
Ran 2 tests in 0.005s

OK
</pre>
